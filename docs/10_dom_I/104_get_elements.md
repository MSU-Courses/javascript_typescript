# Навигация по HTML элементам

Как уже упоминалось ранее, с помощью JavaScript мы можем управлять HTML-элементами. Однако, для того чтобы управлять
HTML-документом, его необходимо получить в JavaScript.

Все возможные операции с элементами DOM начинаются с главного элемента `document`, который является точкой входа.

Прежде всего, важно понять, что при получении любого `HTML-элемента` в JavaScript он становится объектом, с которым мы
можем взаимодействовать. Такой объект обладает своими **свойствами** и **методами**.

Например, `document.body` представляет собой JavaScript объект со свойствами, аналогично с `document.head` и другими
элементами документа, которые мы каким-либо способом будем получать.

# Получение элементов с помощью `document`

Как было описано ранее, мы можем получить основные, верхние `html` элементы.

```js
document.documentElement; // <html>
document.head; // head
document.body; // <body>
```

От них мы можем получать и другие элементы.

## Получение дочерних элементов

Для получения дочерних элементов часто применяются следующие свойства:

* `childNodes` — возвращает всех дочерних узлов (детей).
* `firstChild` — позволяет получить первого ребенка.
* `lastChild` — возвращает последнего ребенка.

```html
<html>
<head>
    <title>Млекопитающие</title>
</head>
<body>
<div>
    <h1>Млекопитающие:</h1>
    <ul>
        <li>Жираф</li>
        <li>Корова</li>
    </ul>
</div>
</body>
</html>
```

```js
document.documentElement.firstChild; // получаем первого ребенка тега <html>
document.documentElement.lastChild; // получаем последнего ребенка тега <html>
```

Метод `childNodes` возвращает всех детей.

```js
document.body.childNodes; // #text (\n), div

for (let i = 0; i < document.body.childNodes.length; i++) {
    console.log(document.body.childNodes[i]);
}

// Результат:
// - #text "\n"
// - <div>
```

Рассмотрим еще один пример.

```js
// Получаем второй дочерний элемент тела документа (в данном случае, это элемент div).
const element = document.body.childNodes[1];
// Проходим по всем дочерним узлам этого элемента.
for (let i = 0; i < element.childNodes.length; i++) { 
    console.log(element.childNodes[i]); // Выводим каждый из дочерних узлов в консоль.
}

// Результат:
// - #text "\n" 
// - <h1> 
// - #text "\n" 
// - <ul> 
// - #text "\n" 
```

> [!NOTE]
> Важно отметить, что `childNodes` не является массивом, а является коллекцией (_особый перебираемый объект_). Например, он не имеет метода `filter`. Для применения метода `filter` необходимо сначала преобразовать его в массив с помощью `Array.from(document.body.childNodes).filter`.

> [!NOTE]
> DOM-коллекции доступны только для чтения, то есть их нельзя изменить. Например, попытка присвоить новое значение элементу коллекции, например, `document.body.childNodes[1] = "div"`, будет невозможной.


## Получение элементов-соседей

Для получения элементов-соседей используются свойства:

* `nextSibling` — следующий сосед
* `previousSibling` — предыдущий сосед

```html
<html>
<head>
    <title>Млекопитающие</title>
</head>
<body>
<div>
    <h1>Млекопитающие:</h1>
    <ul>
        <li>Жираф</li>
        <li>Корова</li>
    </ul>
</div>
</body>
</html>
```

```js
document.body.nextSibling; // "\n"
document.head.nextSibling.nextSibling; // <body>
```

Для получения родителей используется свойство `parentNode`.

```js
document.body.parentNode; // <html>
const divElement = document.body.childNodes[1]; // <div>
divElement.parentNode; // <body>
```

## Получение элементов без текстовых узлов

Обычно нам не требуются текстовые узлы, нам нужно получать только сами элементы: `<div>`, `<h1>`, и так далее.

Для этого применяются следующие свойства:

* `children` — коллекция дочерних узлов (детей), исключая текстовые узлы.
    ```js
    document.body.childNodes; // #text "\n", div
    document.body.children; // <div>
    ```
* `firstElementChild` и `lastElementChild` — первый и последний дочерний элемент, без текстовых узлов.
* `previousElementSibling` и `nextElementSibling` — предыдущий и следующий сосед, без текстовых узлов.
* `parentElement` — родительский элемент, без текстовых узлов.

Попробуйте создать HTML-разметку и поиграться сами.

## Размещение тэга `<script>`

Рассмотрим пример:

```html
<html>
<head>
    <title>Млекопитающие</title>
    <script>
        const body = document.body; // null
    </script>
</head>
<body>
<div>
    <h1>Млекопитающие:</h1>
    <ul>
        <li>Жираф</li>
        <li>Корова</li>
    </ul>
</div>
</body>
</html>
```

Если мы попытаемся обратиться к `document.body` внутри блока `<head>`, результатом будет `null`, что означает "**пусто**" или "**ничего**". Но почему это происходит?

Все дело в том, что при построении DOM-дерева сначала выполнится скрипт в `head`, так как сначала будет построен данный элемент, а только потом создается элемент `body`. Поэтому **скрипты, которые взаимодействуют с HTML, следует помещать в конце документа.**

```html
<html>
<head>
    <title>Млекопитающие</title>
</head>
<body>
<div>
    <h1>Млекопитающие:</h1>
    <ul>
        <li>Жираф</li>
        <li>Корова</li>
    </ul>
</div>
<!-- Корректное размещение -->
<script>
    const body = document.body; // <body>
</script>
</body>
</html>
```